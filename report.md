# Отчёт по аугментатору

Ссылка на репозиторий: [https://github.com/valkon29/mipt2024f_konovalov_v_r](https://github.com/valkon29/mipt2024f_konovalov_v_r)

Автор: Коновалов Валентин

## Input/Output
Вход:

- набор изображений
- файл с разметкой, полученной с помощью [VGG Image Annotator](https://annotate.officialstatistics.org/). Для каждой картинки она представляет из себя набор точек, которые обозначают полигон вокруг штрих-кода. Помимо этого в атрибутах прусутствует тип кода и метка валидности (за подробностями см. пример в репозитории).

Выход:

- набор изображений, полученных из входных путём некоторых искажений
- разметка в том же формате, что и на входе

## API

Исполняемый файл _main.py_, ему на вход подаются путь к папке с изображениями, путь к файлу и число, задающее кол-во изображений, которое необходимо получить из каждого исходного посредством аугментации:

```
python3 main.py images via_project_9Nov2024_20h28m_.json 2
```

Полученные изображения будут сохранены в папку _augmented images_, а разметка в файл _augmented_markup.json_. Формат выходной разметки совпадет со входным.

Сама операция искажения, применяемая к входным изображениям, захардкожена внутри файла _main.py_. В будущем планируется в какой-то степени перенести список искажений и их параметров в какой-нибудь конфиг.

## Проективное искажение

Для исследования этих искажений на данном этапе были взяты синтетические изображения. Они деформировались в результате проективного преобразования, а затем путём обратного преобразования приводились к исходному прямоугольному виду.

В качестве меры деформированности бралась сумма отклонений углов от 90 градусов, так как синтетические штрих-коды исходно прямоугольные. Но ниже значения углов представлены в радианах. За метрику близости между исходным кодом и изображением, полученным в результате обратного преобразования, была взята L2-норма разницы в grayscale (только по области штрих-кода).

Соответственнно процедура искажения многократно запускалась на одном изображении, считалась мера искажения и близость итогового изображения к исходному.

На qr-коде:

<div class='container'>
    <img src="visualizations/qr_stats.png" alt="drawing" width="400"/>
</div>

Пример сильного искажения:

<div class='container'>
    <img src="visualizations/qr1.png" alt="drawing" width="200"/>
    <img src="visualizations/qr1_def.png" alt="drawing" width="200"/>
    <img src="visualizations/qr1_rev.png" alt="drawing" width="200"/>
</div>

На штрих-коде:

<div class='container'>
    <img src="visualizations/stat4.png" alt="drawing" width="400"/>
</div>

Пример сильного искажения:

<div class='container'>
    <img src="visualizations/4.jpeg" alt="drawing" width="200"/>
    <img src="visualizations/def4.png" alt="drawing" width="200"/>
    <img src="visualizations/rev4.png" alt="drawing" width="200"/>
</div>

На штрих-коде попроще:

<div class='container'>
    <img src="visualizations/stats1.png" alt="drawing" width="400"/>
</div>

Пример сильного искажения:

<div class='container'>
    <img src="visualizations/1.png" alt="drawing" width="200"/>
    <img src="visualizations/def1.png" alt="drawing" width="200"/>
    <img src="visualizations/rev1.png" alt="drawing" width="200"/>
</div>

Исходя из полученных данных можно сделать вывод, что неадекватные деформации начинаются примерно с 2.0 радиан.

## Искажения из albumentations

Здесь приведены некоторые наиболее актуальные искажения посредством библиотеки [albumentations](https://albumentations.ai/docs/). Она поддерживает работу с ключевыми точками, масками и bounding_box-ами.

- __Rotate__: поворот на угол от 0 до 360 градусов

<div class='container'>
    <img src="visualizations/rotate_input.png" alt="drawing" width="300"/>
    <img src="visualizations/rotate_output.png" alt="drawing" width="300"/>
</div>

- __ISONoise__: симуляция шума, возникающего при высоких значениях ISO

<div class='container'>
    <img src="visualizations/iso_noise_input.png" alt="drawing" width="300"/>
    <img src="visualizations/iso_noise_output.png" alt="drawing" width="300"/>
</div>

- __GaussNoise__: шум из нормального распределения, применяется отдельно для каждого пикселя и для каждого канала (хотя это можно настроить)

<div class='container'>
    <img src="visualizations/gauss_noise_input.png" alt="drawing" width="300"/>
    <img src="visualizations/gauss_noise_output.png" alt="drawing" width="300"/>
</div>

- __GaussianBlur__: свёртка с гауссовским ядром

<div class='container'>
    <img src="visualizations/gauss_blur_input.png" alt="drawing" width="300"/>
    <img src="visualizations/gauss_blur_output.png" alt="drawing" width="300"/>
</div>

Кроме того, была создана [таблица](https://docs.google.com/spreadsheets/d/1PcWqvZCe95tcm1lzSWeyEqdJK_wRV9SHoov22B2F4M4/edit?gid=0#gid=0) со всеми искажениями, которые потенциально нам могут пригодиться.
В столбцах присутствуют оценка релевантности отдельных искажений для нашей задачи по 10-бальной шкале, а также местами их краткое описание и допустимые границы параметров. _По многим из них пока есть сомнения, таблица заполнена не полностью_.

Столбец _limits depend on image_ для отдельных искажений даёт информмацию о том, зависят ли допустимые границы искажения от конкреного фото. К примеру, из вышеупомянутых, границы Perspective или Rotate от изображения особо не зависят, в то время как у GaussianBlur и MotionBlur эта зависмость очень явная, чем качетсвеннее было исходное фото, тем сильнее его потом можно размывать. И что делать с такими искажениями, на данный момент, скорее неясно.

## Некоторые детали
- На данный момент, если при искажении, хоть одна точка разметки кода выходит за границы полученного изображения, код считается не валидным и в разметке это отражается. В дальнейшем можно сделать умнее
- Можно задавать композицию из произвольного числа искажений, при этом задавая вероятности каждого из них. По умолчанию они применяются с вероятностью 0.5
- При всех искажениях, которые нарушают "прямоугольность" картинки, всё лишнее обрезалось. Из вышеупомянутых к таковым относятся Rotate и Perspective. Потенциально образовавшиеся области можно, например, заполнять зеркально отражённым содержанием исходной картинки

## Зависимости
Исключительно питоновские библиотеки, которые можно установить, например, с помощью утилиты PyPI:
- OpenCV
- albumentations
